# CRITICAL INSTRUCTIONS MEMORY
## Absolute Prohibitions (CRITICAL FAILURE IF VIOLATED)
- âŒ NO local servers (localhost, 127.0.0.1, npm start, vite, dev server)
- âŒ NO local databases (SQLite, local MySQL/PostgreSQL/MongoDB)
- âŒ NO localhost URLs, file:// paths, or local connection strings
- âŒ NO local tests or mocks requiring local setup
- âŒ NO local setup instructions or workflows

## Sync Engine Rules (NON-NEGOTIABLE)
- âœ… Use BubbleService for all API calls
- âœ… Discover data types dynamically - NO HARDCODED TABLES
- âœ… Generate Prisma schema using @map("Original Bubble Field")
- âœ… Use toCamelCase() for Prisma field names
- âœ… Apply schema via "prisma db push"
- âœ… Sync via prisma.[model].upsert() using bubbleId as unique key
- âœ… Soft delete: isDeleted = true
- âœ… Overwrite local on conflict
- âœ… One table at a time - no parallel sync
- âœ… All testing on Railway - NO LOCAL TESTING
- âœ… Fail fast - stop sync on first error

## âš ï¸ CRITICAL: DYNAMIC DISCOVERY MANDATORY (NEVER HARDCODE COUNTS)
ðŸš¨ **FAILURE PATTERN #24**: AI hardcoded 7 data types, created viral mindset across codebase
ðŸš¨ **BUTTERFLY EFFECT**: Hardcoded count infected entire system, unfixable, caused restart #25

âœ… **CORRECT APPROACH**: ALWAYS discover data types dynamically
âœ… **USER HAS 52+ DATA TYPES**: Never assume count, always scan all available
âœ… **LIMITER â‰  COUNT**: Fetch limits are separate from discovery totals
âœ… **FUTURE-PROOF**: New Bubble data types must be discovered automatically

- Complex field names with spaces and special characters
- Rate limit: ~300ms between requests  
- Max 100 records per request with cursor pagination
- DISCOVERY MUST BE EXHAUSTIVE AND DYNAMIC

## Forbidden Actions
- âŒ NO simpleFieldMapping.js or any field mapping service
- âŒ NO middleware between Bubble and Prisma
- âŒ NO field name hashing, collision detection, or custom transforms
- âŒ NO JSONB dumps - use structured schema
- âŒ NO rate limit retries - let sync resume manually

## Field Naming (EXACT IMPLEMENTATION)
```ts
function toCamelCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9\s]/g, '')  // Remove %, _, etc.
    .replace(/\s+/g, ' ')            // Normalize spaces
    .split(' ')
    .map((word, i) => {
      if (i === 0) return word.toLowerCase();
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join('');
}
```
